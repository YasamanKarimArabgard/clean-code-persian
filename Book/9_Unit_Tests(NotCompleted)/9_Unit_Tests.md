# 9 تست های واحد

![unit tests](image-1-1.png "unit tests")

<div dir="rtl">

حرفه ما مسیر زیادی را در طی 10 سال گذشته پیموده است. در سال 1997 هیچکس در مورد توسعه آزمون محور چیزی نشنیده بود. برای اکثریت قریب به اتفاق ما ، تست های واحد چند خط کد بدرد نخور بودند که مطمئن شویم برنامه کار میکند. ما با زحمت کلاس ها و متد هایمان را مینوشتیم و بعد با چندین خط کد کثیف و از سرباز کنی، آن ها را تست می کردیم. معمولاً این حرکت شامل این میشود که یک برنامه درایور ساده را به پروژه اضافه کنیم، تا بتوانیم به صورت دستی کد را تست کنیم.

یادم میاد در اواسط دهه 90 داشتم یک برنامه با زبان ++C برای یک سیستم نهفته می نوشتم. برنامه یک تایمر ساده به شرح زیر بود:

`void Timer::ScheduleCommand(Command* theCommand, int milliseconds)`

الگوریتم کار ساده بود، متد execute از آبجکت command باید بعد از گذشت چند میلی ثانیه مشخص داخل یک ترد جدید فراخوانی می شد. اما مشکل اصلی این بود که چه طور باید این الگوریتم را تست کنیم.
برای انجام این کار خیلی سریع یک برنامه درایور صفحه کلید نوشتم. هر وقت که یک حرف تایپ می شد، برنامه فرمان چاپ را پنج ثانیه بعد صادر میکند. سپس یک شعر ریتمیک را تایپ کردم و منتظر ماندم تا شعر با پنج ثانیه تاخیر در صفحه چاپ شود.

"من ... یکی رو میخواستم ... فقط ... اون دختری که از ... دواج ... کرد ... با بابای ... عزیز... و پیرم"

در واقع من آن  شعر را در حالی که کلید "." را تایپ میکردم می خواندم. و بعد آن را دوباره هنگامی که نقطه ها چاپ شده بودند، خواندم.
این تست من شد! بعد از اینکه از کار کردن آن مطمئن شدم و آن را برای همکارانم توضیح دادم، کد تست را پاک کردم.
همینطور که قبلا گفتم، حرفه ما راه زیادی را طی کرده است. امروزه من برای تمام سوراخ و سنبه ها و گوشه های نرم افزار تست می نویسم تا مطمئن باشم همانطوری که من انتظار دارم کار می کند. من وابستگی کد را نسبت به سیستم عامل حذف میکنم، به جای آنکه بخواهم توابع مدیریت زمان مربوط به سیستم عامل را صدا بزنم. من برای کنترل کامل بر زمان، تمام توابع مدیریت زمان را به صورت جعلی می نویسم. من فرمان هایی که پرچم های وضعیت را تغییر می دهند، برنامه ریزی میکنم و بعد زمان را جلو می برم و پرچم ها را زیر نظر میگیرم که مقدارشان از false به true تغییر کند، آن هم درست زمانی که من مقدار زمان را تغییر دهم. 
وقتی که تمام تست ها پاس شدند، من مطمئن می شوم که اجرا کردن آن ها برای هر کسی که نیاز دارد با کد کار کند، راحت باشد. همینطور مطمئن می شوم که کد و تست با هم در یک پکیج حاضر شوند.
بله ما راه زیادی را طی کرده ایم. ، اما هنوز باید جلوتر برویم. روش چابک (Agile) و توسعه آزمون محور (TDD) خیلی از برنامه نویس ها را تشویق کرده که تست های واحد اتوماتیک بنویسند و همینطور به تعداد آن ها افزوده می شود. اما عجله زیاد برای افزودن تست، باعث شده که بسیاری از برنامه نویسان نکات مهم و حیاطی نوشتن تست خوب را جا بیندازند.

## سه قانون توسعه آزمون محور

تا الان همه می دانند که توسعه آزمون محور از ما میخواهد قبل از نوشتن کد نهایی (Production Code)، تست های واحد را بنویسیم. اما این قانون فقط قسمت کوچکی از توسعه آزمون محور است. این سه قانون را در نظر بگیرید:
<br />
**قانون اول** تنها زمانی شروع به نوشتن کد نهایی کنید که می خواهید یک تست شکست خورده را پاس کنید.
<br />
**قانون دوم** با شکست خوردن تست از نوشتن تست بعدی جلوگیری کنید.
<br />
**قانون سوم** تنها به مقداری کد نهایی بنویسید که برای پاس کردن تست شکست خورده کافی باشد.
<br />
این سه قانون شما را وارد یک چرخه ای می کند که شاید 30 ثانیه طول بکشد. تست ها و کد نهایی با هم نوشته می شوند، با این تفاوت که تست ها چند ثانیه از کد نهایی جلوتر هستند.
اگر ما به این روش کار کینم، ده ها تست به طور روزانه، صد ها تست ماهانه و هزاران تست در سال خواهیم نوشت. اگر به این روش کار کینم، این تست ها تمام کد های نهایی ما را پوشش می دهند. بخش عمده این تست ها که میتواند با اندازه کد نهایی رقابت کند، میتواند یک مشکل مدیریتی دلهره آور را ایجاد کند.

## تمیز نگه داشتن کدها 

چندسال پیش از من درخواست شده بود تا مربی تیمی شوم که صراحتا تصمیم گرفته بود کد آزمون آن ها نباید مطابق با استاندارد کیفیت تولید آن ها نگهداری 
شود.آن ها به یکدیگر اجازه می دادند تا در آزمون های واحد خود قوانین را زیرپا بگذارند.کلیدواژه "سریع و کثیف بود.متغیرهای آن ها لازم نیست با نام های خوبی نام گذاری شود و توابع لازم نیست تا کوتاه و توصیفی باشند.کد آزمون آن ها لازم نیست به خوبی طراحی و فکر شده تقسیم بندی شده باشد.تا 
زمانی که کد تست کار می کرد و تا زمانی که  کدتولید را پوشش می داد به اندازه کافی خوب بود.
<br />
 بعضی از شماها که در حال خواندن این متن هستید ممکن است با آن همدردری کنید.شاید شما در زمان گذشته آزمون هایی از نوع همان که من برای آن تایمر  نوشتم می نوشتید.این یک قدم بزرگ برای نوشتن این نوع آزمون بدردنخور است برای نوشتن مجموعه ای از  آزمون های واحد خودکار است.خب مثل تیمی که من مربی آن ها بودم ممکن است شماهم این تصمیم را بگیرید که داشتن آزمون های کثیف بهتر از نداشتن آزمون است.
<br />
چیزی که این تیم متوجه نشده بود این بود که داشتن آزمون های کثیف بدتر از نداشتن آزمون است.مشکل این است که آزمون ها باید با تکامل کد تولید تغییر کنند.هرچقدر آن ها کثیف تر باشند سخت تر می توان آن ها را تغییر داد.هرچقدر کد آزمون درهم تر باشد ،احتمال اینکه شما وقت بیشتری را صرف جمع کردن آزمون های بیشتری کنید بیشتر از نوشتن کد تولید جدیداست. همانطور که شما کدهای تولید را تغییر می دهید آزمون های قدیمی شروع به شکست خوردن می کنند و آشفتگی در کد تست ها ،گذراندن مجدد آن آزمون ها را سخت می کند.پس آزمون ها مثل یک بدهی رو به افزایش در نظر گرفته می شوند.
<br />
هزینه نگهداری مجموعه آزمایشی تیم من از زمان انتشار تا آزادسازی افزایش یافت.در نهایت این مورد به بزرگترین شکایت در میان توسعه دهندگان تبدیل شدزمانی که مدیران پرسیدند چرا تخمین‌هایشان اینقدر بزرگ شده است، توسعه‌دهندگان آزمایش‌ها را مقصر می‌دانستند.در پایان آنها مجبور شدند مجموعه آزمایشی را به طور کامل دور بیندازند.
<br />
اما بدون مجموعه آزمون ها آن ها این توانایی که تغییرات در پایه کد آن ها همان طور که انتظار می رفت کار می کند را از دست دادند.بدون مجموعه آزمون ها آن ها نمی توانستند اطمینان حاصل کنند که تغییرات در در یک قسمت از سیستم آن ها باعث خراب شدن سایر بخش های سیستم آن ها نمی شود.بنابراین میزان 
نقص آنها شروع به افزایش کرد.با افزایش تعداد نقص های ناخواسته، آنها شروع به ترس از ایجاد تغییرات کردند .آن ها تمیز کردن کدهایشان را متوقف .کردند زیرا می ترسیدند تغییرات آن ها بیشتر از اینکه مفید باشد ضرر داشته باشد.کد تولید آن ها شروع به پوسیده شدن کرد.در آخرآن ها بدون آزمون ها ماندند . کد تولیددرهم و پر از اشکال ،مشتریان نا امید شدند و احساس می کردند آزمایش آن ها را شکست داده است
<br />
به نوعی حق با آن ها بود آزمایش آن ها را شکست داده بوداما این تصمیم آن ها بود که اجازه دادند کدها درهم باشند و این بذر شکست آن ها را کاشت!اگر کد ها را تمیز نگه می داشتند آزمایش آن ها شکست نمی خورد.این را می توانم با قاطعیت بگویم زیرا در تیم های زیادی حضور داشته و مربیگری کرده ام که با واحد تمیز موافق بوده اند.
<br />
نکته اخلاقی داستان ساده است کد آزمون ها به اندازه کد تولید مهم است.این یک جنس درجه دو یا کم ارزش نیست پس نیاز به تفکر و طراحی دارد و باید همانند کد تولید تمیز نگه داشته شود.

## آزمون ها مشکلات را به وجود می آورند  

اگر شما کدهایتان را تمیز نگهداری نکنید آن ها را از دست خواهید داد،و بدون آن ها شما همان چیزی که تولید شما را منعطف نگه می دارد را از دست می دهید.بله شما آن را درست خواندید . این آزمون های واحد هستند که کد ما را انعطاف پذیر ،قابل نگهداری و قابل استفاده مجدد نگه می دارند.علت آن ساده است، اگر شما آزمون ها را دارید دیگر نباید از تغییر در کدهایتان بترسید! بدون آزمون ها هر تغییری می تواند یک مشکل باشد. مهم نیست که معماری کد شما چقدر انعطاف پذیر است،مهم نیست طراحی شما چقدر خوب تقسیم بندی شده است  ،بدون آزمون ها شما از ترس اینکه اشکالات شناسایی نشده را معرفی کنید تمایلی به ایجاد تغییرات ندارید.
<br />
اما با داشتن آزمون ها ترس ها عملا از بین می روند هر چقدر پوشش تست شما بیشتر باشد شما کمتر می ترسید. شما می توانید بدون جریمه کدهایی را تغییر  که معماری کمتر ستاره ای و طراحی درهم و نا واضح هستند در واقع شما می توانید آن معماری را بدون ترس بهبود ببخشید.بنابر این داشتن مجموعه ای خودکار از آزمون های واحد که کد تولید را پوشش می دهند کلید این است تا معماریتان و طراحیتان را به تمیز ترین شکل ممکن نگهداری کنید.آزمون ها مشکلات را فعال می کنند زیرا آزمون ها اعمال تغییرات را امکان پذیر می کنند.
<br />
پس اگر کد آزمون های شما کثیف هستند شما برای اینکه در کدتان تغییر ایجاد کنید با مشکل مواجه می شوید و شما شروع به از دست داد توانایی خود در ایجاد بهبود درساختار آن کد می شوید.هر چقدر آزمون های شما کثیف تر باشد کد شما نیز کثیف تر می شود. در نهایت آزمون ها را از دست می دهیدو کد شما پوسیده می شود.

## آزمون های تمیز

 چه چیزی یک تست تمیز را می سازد؟سه چیز:خوانایی،خوانایی و خوانایی.خوانایی شاید در آزمون های واحد مهم تر از کد تولید باشد.چه چیزی یک آزمون را خوانا می کند؟همان چیزی که همه کدها را قابل خواندن می کند :در یک آزمون شما می خواهید با کمترین عبارات ممکن چیزهای زیادی بگویید.
<br />
کد FitNesse را در فهرست 9-1 در نظر بگیرید. درک این سه آزمون دشوار است و مطمئناً قابل بهبود هستند. اول، مقدار وحشتناکی از کد تکراری [G5] در تماس های مکرر به addPage و assertSubString وجود دارد. مهمتر از آن، این کد فقط با جزئیاتی بارگذاری شده است که با بیان آزمون تداخل دارد. 
<br />

Listing 9-1

SerializedPageResponderTest.java

`public void testGetPageHieratchyAsXml() throws Exception{<br />
crawler.addPage(root, PathParser.parse("PageOne"));
crawler.addPage(root, PathParser.parse("PageOne.ChildOne"));
crawler.addPage(root, PathParser.parse("PageTwo"));
request.setResource("root");
request.addInput("type", "pages");
Responder responder = new SerializedPageResponder();
SimpleResponse response =
(SimpleResponse) responder.makeResponse(
new FitNesseContext(root), request);
String xml = response.getContent();
assertEquals("text/xml", response.getContentType());
assertSubString("<name>PageOne</name>", xml);
assertSubString("<name>PageTwo</name>", xml);
assertSubString("<name>ChildOne</name>", xml);
}
public void testGetPageHieratchyAsXmlDoesntContainSymbolicLinks()
throws Exception
{
WikiPage pageOne = crawler.addPage(root, PathParser.parse("PageOne"));
crawler.addPage(root, PathParser.parse("PageOne.ChildOne"));
crawler.addPage(root, PathParser.parse("PageTwo"));
PageData data = pageOne.getData();
WikiPageProperties properties = data.getProperties();
WikiPageProperty symLinks = properties.set(SymbolicPage.PROPERTY_NAME);
symLinks.set("SymPage", "PageTwo");
pageOne.commit(data);
request.setResource("root");
request.addInput("type", "pages");
Responder responder = new SerializedPageResponder();
SimpleResponse response =
(SimpleResponse) responder.makeResponse(
new FitNesseContext(root), request);
String xml = response.getContent();
assertEquals("text/xml", response.getContentType());
assertSubString("<name>PageOne</name>", xml);
assertSubString("<name>PageTwo</name>", xml);
assertSubString("<name>ChildOne</name>", xml);
assertNotSubString("SymPage", xml);
}
public void testGetDataAsHtml() throws Exception
{
crawler.addPage(root, PathParser.parse("TestPageOne"), "test page");
request.setResource("TestPageOne");
request.addInput("type", "data");
Responder responder = new SerializedPageResponder();
SimpleResponse response =
(SimpleResponse) responder.makeResponse(
new FitNesseContext(root), request);
String xml = response.getContent();
assertEquals("text/xml", response.getContentType());
assertSubString("test page", xml);
assertSubString("<Test", xml);
}`

<br />
به عنوان مثال به فراخوانی های PathParser نگاه کنید.آن ها رشته ها را به نمونه های PathPage  تبدیل می کنند که توسط crawler استفاده می شود. این تبدیل کاملاً بی ربط به آزمون حاضر است و فقط هدف را مبهم  می کند. جزئیات مربوط به ایجاد پاسخ دهنده و جمع آوری و ریخته گری پاسخ نیز فقط نویز است. سپس راهی وجود دارد که URL درخواست از یک منبع و یک آرگومان ساخته می شود. )من به نوشتن این کد کمک کردم، بنابراین می توانم به طور کامل از آن انتقاد کنم).
<br />
در نهایت این کد برای خواندن طراحی نشده است.خواننده کم تجربه با انبوهی از جزییات مواجه می شود که قبل از اینکه آزمون ها واقعی شوند ( اجرایی شوند ) باید درک شوند.
<br />
در نهایت این کد برای خواندن طراحی نشده است.خواننده کم تجربه با انبوهی از جزییات مواجه می شود که قبل از اینکه آزمون ها واقعی شوند ( اجرایی شوند ) باید درک شوند. اکنون آزمون های بهبود یافته در فهرست 9-2 را در نظر بگیرید.
این آزمون ها دقیقاً همین کار را انجام می‌دهند، اما به شکلی بسیار تمیزتر و واضح تر تبدیل شده‌اند.
<br />

Listing 9-2

SerializedPageResponderTest.java (refactored)

`public void testGetPageHierarchyAsXml() throws Exception {<br />
makePages("PageOne", "PageOne.ChildOne", "PageTwo");<br />
submitRequest("root", "type:pages");<br />
assertResponseIsXML();<br />
assertResponseContains(<br />
"<name>PageOne</name>", "<name>PageTwo</name>", "<name>ChildOne</name>")<br />
}`<br />
`public void testSymbolicLinksAreNotInXmlPageHierarchy() throws Exception {<br />
WikiPage page = makePage("PageOne");<br />
makePages("PageOne.ChildOne", "PageTwo");<br />
addLinkTo(page, "PageTwo", "SymPage");<br />
submitRequest("root", "type:pages");<br />
assertResponseIsXML();<br />
assertResponseContains(<br />
"<name>PageOne</name>", "<name>PageTwo</name>", "<name>ChildOne</name>");<br />
assertResponseDoesNotContain("SymPage");<br />
}`<br />

`public void testGetDataAsXml() throws Exception {<br />
makePageWithContent("TestPageOne", "test page");<br />
submitRequest("TestPageOne", "type:data");<br />
assertResponseIsXML();<br />
assertResponseContains("<br />
}`

<br />
الگوی BUILD-OPERATE-CHECK2 با ساختار این تست ها آشکار می شود. هر یک از آزمون ها به وضوح به سه بخش تقسیم می شوند.
بخش اول داده های آزمون را می سازد ، بخش دوم روی آن داده های آزمایشی کار می کند و بخش سوم برررسی می کند که آیا عملیات نتایج مرود انتظار را به همراه داشته است .
<br />
توجه داشته باشید که بیشترجزییات آزاردهنده (مشکل ساز) حذف شده اند. تست ها دقیقاً به نقطه اصلی می رسند و فقط از داده ها و توابعی استفاده می کنند که واقعاً به آنها نیاز دارند. هر کسی که این آزمون‌ ها را می‌خواند باید بتواند کارهایی را که انجام می‌دهد خیلی سریع بدون اشتباه یا بدون دقت در جزئیات انجام دهد.
<br />

## زبان آزمون دامنه خاص

آزمون ‌های فهرست 9-2 تکنیک ساخت یک زبان دامنه خاص برای آزمون‌های شما را نشان می‌دهند. به‌جای استفاده از APIهایی که برنامه‌نویسان برای دستکاری سیستم استفاده می‌کنند، مجموعه‌ای از توابع و ابزارهای کاربردی ایجاد می‌کنیم که از آن APIها استفاده می‌کنند و تست‌ها را برای نوشتن راحت‌تر و خواندن آسان‌تر می‌کنند. این توابع و ابزارهای کاربردی تبدیل به یک API تخصصی می شوند که توسط آزمون ها استفاده می شود. آنها یک زبان آزمون هستند که برنامه نویسان برای کمک به خودشان در نوشتن آزمون ها و برای کمک به کسانی که بعداً باید آن آزمون ها را بخوانند از آن استفاده می کنند.
<br />
این API آزمایشی از قبل طراحی نشده است. بلکه از بازسازی مداوم کد آزمون که بیش از حد با جزئیات مبهم شده است، به وجود آمده است همانطور که دیدید من لیست 9-1 را به لیست 9-2 تغییر می دهم، توسعه دهندگان منظم تر نیز کد آزمون خود را به شکل های مختصر و گویا تر تغییر می دهند.

## یک استاندارد دوگانه 

از طرفی تیمی که در ابتدای فصل به آن اشاره کردم شرایط درستی داشت. کد موجود در API آزمایشی دارای مجموعه‌ای از استانداردهای مهندسی متفاوت از کد تولید است. هنوز هم باید ساده، مختصر و گویا باشد، اما لازم نیست به اندازه کد تولید کارآمد باشد. به هر حال، در یک محیط آزمون اجرا می شود، نه یک محیط تولید، و این دو محیط نیازهای بسیار متفاوتی  دارند.
<br />
آزمون فهرست 9-3 را در نظر بگیرید. من این آزمون را به عنوان بخشی از یک سیستم کنترل محیط  که در حال ساخت نمونه اولیه بودم نوشتم.
بدون پرداختن به جزئیات، می‌توانید بگویید که این آزمایش بررسی می‌کند که هشدار دمای پایین، بخاری و دمنده همگی در زمانی که دما «خیلی پایین است» روشن می‌شوند.
<br />

Listing 9-3

EnvironmentControllerTest.java

`@Test
public void turnOnLoTempAlarmAtThreashold() throws Exception {<br />
hw.setTemp(WAY_TOO_COLD);<br />
controller.tic();<br />
assertTrue(hw.heaterState());<br />
assertTrue(hw.blowerState());<br />
assertFalse(hw.coolerState());<br />
assertFalse(hw.hiTempAlarm());<br />
assertTrue(hw.loTempAlarm());<br />
}`

<br />
البته در اینجا جزئیات زیادی وجود دارد. به عنوان مثال، آن تابع tic در مورد چیست؟ در واقع، ترجیح می‌دهم هنگام خواندن این آزمون نگران این موضوع نباشید. ترجیح می‌دهم فقط نگران این باشید که آیا موافقید که وضعیت پایانی سیستم با "خیلی سرد بودن" دما مطابقت دارد یا خیر.
<br />
البته در اینجا جزئیات زیادی وجود دارد. به عنوان مثال، آن تابع tic در مورد چیست؟ در واقع، ترجیح می‌دهم هنگام خواندن این آزمون نگران این موضوع نباشید. ترجیح می‌دهم فقط نگران این باشید که آیا موافقید که وضعیت پایانی سیستم با "خیلی سرد بودن" دما مطابقت دارد یا خیر. توجه کنید، همانطور که آزمون را می خوانید، چشم شما باید بین نام حالتی که بررسی می شود و وضعیت حالتی که بررسی می شود به عقب و جلو بچرخد. HeaterState را می بینید، و سپس چشمان شما به سمت چپ می رود تا به عنوان "True" اعلام شود. شما coolerState را می بینید و چشمان شما باید سمت چپ را دنبال کند تا assertFalse شود. این خسته کننده و نا مطمئن است و خواندن آزمون را سخت می کند.
<br />
من خواندن این آزمون را با تبدیل آن به لیست 9-4 بسیار بهبود دادم.
<br />

`Listing 9-4

EnvironmentControllerTest.java (refactored)

@Test<br />
public void turnOnLoTempAlarmAtThreshold() throws Exception {<br />
wayTooCold();<br />
assertEquals("HBchL", hw.getState());<br />
}`

<br />


البته من جزئیات تابع tic را با ایجاد یک تابع wayTooCold پنهان کردم. اما نکته ای که باید به آن توجه کرد رشته عجیب در assertEquals است. حروف بزرگ به معنی روشن، حروف کوچک به معنی خاموش و حروف همیشه به ترتیب زیر هستند: 
`{heater, blower, cooler,hi-temp-alarm, lo-temp-alarm}`.
<br />
اگرچه این امر شبیه به یک تجسم ذهنی است، در این مورد مناسب به نظر می رسد. توجه کنید، هنگامی که متوجه آن باشید، چشمانتان به سمت آن سر می خورد آن رشته و شما می توانید به سرعت نتایج را تفسیر کنید. خواندن تست تقریباً به یک لذت تبدیل می شود. فقط نگاهی به لیست 9-5 بیندازید و ببینید درک این تست ها چقدر آسان است.
<br />

Listing 9-5

EnvironmentControllerTest.java (bigger selection)
<br />
`@Test<br />
public void turnOnCoolerAndBlowerIfTooHot() throws Exception {<br />
tooHot();<br />
assertEquals("hBChl", hw.getState());<br />
}<br />
@Test<br />
public void turnOnHeaterAndBlowerIfTooCold() throws Exception {<br />
tooCold();<br />
assertEquals("HBchl", hw.getState());<br />
}<br />
@Test<br />
public void turnOnHiTempAlarmAtThreshold() throws Exception {<br />
wayTooHot();<br />
assertEquals("hBCHl", hw.getState());<br />
}<br />
@Test<br />
public void turnOnLoTempAlarmAtThreshold() throws Exception {<br />
wayTooCold();<br />
assertEquals("HBchL", hw.getState());<br />
}`<br />

<br />
تابع getState در لیست Listing 9-6 نشان داده شده است.توجه کنید که کد خیلی کارآمد نیست و برای اینکه آن را کارآمد کنیم احتمالا باید StringBuffer  را استفاده کنیم.
<br />

Listing 9-6
<br />
MockControlHardware.java

public String getState() {<br />
String state = "";<br />
state += heater ? "H" : "h";<br />
state += blower ? "B" : "b";<br />
state += cooler ? "C" : "c";<br />
state += hiTempAlarm ? "H" : "h";<br />
state += loTempAlarm ? "L" : "l";<br />
return state;<br />
}<br />

<br />
StringBuffer  ها کمی نازیبا هستند.حتی اگر هزینه در کد تولید  بسیار کم باشد من از آن ها اجتناب می کنم و می توانید استدلال کنید که هزینه در کد در لیست  6-9 بسیار ناچیز است به هر حال این اپلیکیشن یک سیستم بلادرنگ تعبیه شده است و به نظر می رسد منابع رایانه و حافظه بسیار محدود هستند. محیط آزمون به احتمال زیاد اصلا محدود نیست.
<br />
این طبیعت استاندارد دوگانه است. در محیط آزمون چیزهایی وجود دارند که ممکن است شما در محیط تولید انجام ندهید اما در محیط آزمون بسیار خوب هستند.معمولا آن ها مسائل مربوط به حافظه و کارایی پردازنده را شامل می شوند.اما آن ها هرگز مسائل تمیزی کد را شامل نمی شوند. 
<br />

## یک ادعا در آزمون


